<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h2>TPA - Total Precision Arithmetic</h2><p><a href="http://travis-ci.org/dthwaite/TPA"><img src="https://secure.travis-ci.org/dthwaite/TPA.png" alt="Build Status"></a></p>
<h5>tpa.js performs basic arithmetic operations with total precision.</h5><p>Available on <a href="https://github.com/dthwaite/TPA">GitHub</a>, details on <a href="http://dthwaite.github.io/tpa/docs/">JsDocs</a>. See it working: <a href="http://dthwaite.github.io/tpa/">Demonstration</a></p>
<p>The main features are:</p>
<ul>
<li>Simplicity - one library, add/subtract/multiply/divide</li>
<li>Performance - optimised to perform operations very, very fast</li>
<li>Limitless - represents and operates on rational numbers of any size and precision</li>
<li>Expressive - inputs/outputs numbers using decimal or fractional forms</li>
<li>Quality - comprehensively tested and documented</li>
</ul>
<p>For a terse list of methods go to the end of this readme. The usage section below is more descriptive.</p>
<p>There are many similar libraries available. I wrote this one partly as an exercise. But I also wrote it because it achieves all the features listed above as well as, or considerably better (IMHO ;-), than the others.</p>
<p>Installation:<br><code>npm install</code></p>
<p>Test:<br><code>npm test</code></p>
<p>To use in Node:</p>
<pre class="prettyprint source lang-javascript"><code>var Tpa = require('Tpa');

var n=new Tpa(100.123);
console.log(n.toString()); // Outputs '123.123'</code></pre><p>To use in the browser:</p>
<pre class="prettyprint source lang-javascript"><code>&lt;script src =&quot;https://cdn.rawgit.com/dthwaite/TPA/master/lib/tpa.min.js&quot;>&lt;/script>
&lt;script>
var n=new Tpa(100.123);
console.log(n.toString()); // Outputs '123.123'
&lt;/script></code></pre><h3>Usage</h3><h4>Set up</h4><pre class="prettyprint source lang-javascript"><code>var n1=new Tpa();                // new integer set to zero
var n2=new Tpa(123);             // new integer set to 123
var n3=new Tpa(213.5);           // new fraction set to 123.5
var n4=new Tpa('123');           // new integer set to 123
var n5=new Tpa('123.3[3]');      // new fraction set to 123 1/3
var n6=new Tpa('123 1/3');       // new fraction set to 123 1/3
var n7=new Tpa('-4 538/1284');   // new fraction set to to -4.41900311...
var n8=new Tpa('-.2[512]');      // new fraction
n8.set(-9);                      // Sets an existing number to a new value
n8.set();                        // resets an existing number to zero
n8.set('-4 538/1284');           // resets an existing number 4.41900311...
n8.set(n2);                      // Sets an existing number to equal another (takes a copy)</code></pre><p>As can be seen above, setting a number with a string representation is the best way as you can express any rational number with complete accuracy using either a decimal form (with optional recurring digits) or a fractional form.</p>
<h4>Outputs</h4><p>Numbers can be output in decimal (<code>toDecimal()</code>) or fractional (<code>toFraction()</code>) form. Decimal places are limited to 100 unless specified in the <code>toString()</code> or <code>toDecimal()</code> methods.</p>
<pre class="prettyprint source lang-javascript"><code>console.log(n1.toString());      // '0'
console.log(n2.toString());      // '123'
console.log(n2.value());         // 123.0
console.log(n3.toString());      // '123.5'
console.log(n3.toDecimal());     // '123.5' (alias for toString())
console.log(n3.toFraction());    // '123 5/10'
n3.simplify();
console.log(n3.toFraction());    // '123 1/2'
console.log(n5.toDecimal());     // '123.[3]
console.log(n5.toFraction());    // '123 30/90'
console.log(n7.toFraction());    // '-4 538/1284'
n7.simplify();
console.log(n7.toFraction());    // '-4 269/642'
console.log(n7.toDecimal());     // '-4.4[19003115264797507788161993769470404984423676012461059]'
console.log(n7.toDecimal(20));   // '-4.41900311526479750778...' (limit dp's to 20)</code></pre><p>Note that there is a <code>value()</code> method that gives the number as a javascript floating point number. This will clearly be an approximation in many cases.</p>
<h4>Operations</h4><p>Methods <code>add()</code>, <code>subtract()</code>, <code>multiply()</code> and <code>divide()</code> all operate in-situ on the number on which they are called. They return the number to allow for chaining of operations. Each takes a parameter that may either be an existing <code>Tpa</code> object (which is not changed) or a number or string that is a valid representation. Aliases for the above are: <code>plus()</code>, <code>sub()</code>, <code>minus()</code>, <code>mult()</code>, <code>times()</code>, <code>div()</code>.</p>
<pre class="prettyprint source lang-javascript"><code>console.log(n2.add(n2).toString());         // '246'
console.log(n2.subtract(123).toString());   // '123'
n2.subtract('200');
console.log(n2.toDecimal());                // '-77'
n2.add(new Tpa(200));
console.log(n2.toDecimal());                // '123'
console.log(n5.multiply(n3).toString());    // '26331.[6]' (123 3/9 * 123.5)
n5.divide(n3);
console.log(n5.toString());                 // '123.[3]'
n5.subtract('23 1/3').divide(2).add('48 2/1').divide(-100);
console.log(n5.toString());                 // '-1'</code></pre><h4>Integer and Fractions</h4><p>Tpa numbers are declared either <em>integer</em> or <em>fractional</em>. If integer then all operations performed on them will only use the integer part of their operands. Whether a number is integer or fractional is inferred from its initialisation. But you can force the issue by passing <code>true</code> (for integer) or <code>false</code> (for fractional) as an additional parameter to the <code>Tpa</code> constructor</p>
<pre class="prettyprint source lang-javascript"><code>var a=new Tpa(3);                           // Constructs a to be integer
var b=new Tpa(7.8);                         // Constructs b to be fractional
a.add(b);
console.log(a.toString());                  // '10' (a is an integer and ignores fractional operands)
var c=new Tpa(3,false);                     // Explicitly set a to be fractional
c.add(b);
console.log(c.toString());                  // '10.8' (c is fractional and so operates on fractional operands)
var d=new Tpa(b,true);                      // Explicitly set d to be integer
console.log(d.toString());                  // '7' (d was constructed to ignore any fractional part)
var e=new Tpa('23 100/23',true);            // Explicitly set e to be integer
console.log(e.value());                     // 27 (e took on the integer evaluation of the initialising string)
console.log(e.set(3,false));                // Sets an existing number tto a new value and to be fractional</code></pre><p>You can find out what type a number is with the <code>isInteger()</code> and <code>isFractional()</code> methods and you can convert a number to one or other representation with the <code>makeInteger()</code> and <code>makeFractional()</code> methods:</p>
<pre class="prettyprint source lang-javascript"><code>var a=new Tpa('33 2/3');
console.log(a.isInteger());                 // false
console.log(a.makeInteger().value());       // 33
console.log(a.isInteger());                 // true
var b=new Tpa(10);
console.log(b.makeFractional().subtract(11.5).value()); // -1.5
console.log(b.isFractional());                 // true
console.log(b.makeInteger().toDecimal());    // '-1'</code></pre><p>The reason Tpa makes a distinction is that a common requirement is simply to deal with integers. Processing fractions for the four main operations is a significant overhead. In fact it can quite quickly lead to massive numerators and denominators in fractional parts of numbers in order to maintain total precision. Keep this in mind.</p>
<p>Fractions are never automatically simplified. However, the <code>simplify()</code> method makes its best attempt to simplify the fractional part of a number. Reducing a very large fraction is compute intensive (just as well because most encryption mechanisms rely on this fact!) as it essentially involves trying to find common prime factors.</p>
<pre class="prettyprint source lang-javascript"><code>var n=new Tpa('1/3');
n.multiply('3/5').multiply('9/7').multiply('23/45').multiply('12 45/87').divide('99.75');
console.log(n.toString(25));                // '0.0164924626838031038186599...'
console.log(n.toFraction());                // '0 67626900/4100473125'
console.log(n.simplify());                  // true - indicates that simplification was fully achieved
console.log(n.toFraction());                // '0 11132/674975'
n=new Tpa('234789789167435342333343/4239123411142533478912');
console.log(n.simplify());                  // false - defaults to 100 ms which is probably not enough time
console.log(n.toFraction());                // '55 1638001554596000993183/4239123411142533478912'
console.log(n.simplify(0));                 // true - achieved full simplification
console.log(n.toFraction());                // '55 1638001554596000993183/4239123411142533478912'</code></pre><p>It is often the case that the fractional form is more terse than a decimal read out. The decimal form of the number resulting from that chain of computations has a recurring decimal section of 252 digits while the simplified fraction involves considerably less digits.</p>
<p>The <code>simplify()</code> method does not look for any common prime factors above 33,554,393. It also limits its computation to 100 milliseconds. You can bypass this by passing in the number of milliseconds you are prepared to wait or 0 to indicate no limit. The system builds up its own inventory of prime numbers and it may take several seconds to simplify the first time (assuming you permit it) as it creates this inventory. But subsequent simplifications will generally be achieved within one second. <code>simplify()</code> returns true if the fraction has been fully simplified otherwise it may or may not have been fully simplified as either the fraction may have a common factor above 33,554,393 or time has run out.</p>
<h4>Comparisons</h4><p>There are a selection of comparison methods, namely: <code>isZero()</code>, <code>isPositive()</code>, <code>isNegative()</code>, <code>lt()</code>, <code>lte()</code>, <code>gt()</code>, <code>gte()</code> and  <code>eq()</code></p>
<pre class="prettyprint source lang-javascript"><code>var a=Tpa(3);
var b=Tpa(3.5);
var c=Tpa('4 1/4');
var d=Tpa('3 5/4');
var f=Tpa();
console.log(a.isZero());            // false
console.log(a.isPositive());        // true
console.log(f.isPositive());        // false (it's zero)
console.log(b.isNegative());        // false
console.log(a.lt(b));               // false (a is an integer and ignores fractional operands)
console.log(a.lt(c));               // true
console.log(d.lte(c));              // true (they are equal)
console.log(d.gte(c));              // true (ditto)
console.log(d.gt(c));               // false
console.log(d.eq(c));               // true</code></pre><h4>Other methods</h4><ul>
<li><code>sign()</code> returns -1, 0 or 1 if the number is negative, zero or positive respectively</li>
<li><code>hasFraction()</code> return true if the number has a non zero fractional part</li>
<li><code>frac()</code> removes the integer value from the number</li>
<li><code>int()</code> removes the fractional value from the number</li>
<li><code>mod()</code> set this number to the modulus of the number passed in</li>
<li><code>abs()</code> set this number to its absolute value</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>console.log(Tpa(-3).sign());                        // -1
console.log(Tpa(3.3).hasFraction());                // true
console.log(Tpa('-3 1/3').frac().toFraction());     // '-0 1/3'
console.log(Tpa('-3 1/3').int().toFraction());      // '-3'
console.log(Tpa(22).mod(3).toString());             // '1'
console.log(Tpa(-33.5).abs().value());              // 33.5</code></pre><h4>Static methods</h4><p>Typically the arithmetical operations change the number on which they are called. Alternatively you can choose to not mutate existing numbers to return a new number which is the result of the operation. This is achieved with static functions as follows:</p>
<ul>
<li><code>Tpa.add(a,b)</code> adds a and b and returns the result in a new number (aliases: <code>plus()</code>)</li>
<li><code>Tpa.subtract(a,b)</code> subtracts b from a and returns the result in a new number (aliases: <code>sub()</code> &amp; <code>minus()</code>)</li>
<li><code>Tpa.multiply(a,b)</code> multiplies two numbers and returns the result in a new number (aliases: <code>times()</code> &amp; <code>mult()</code>)</li>
<li><code>Tpa.divide(a,b)</code> divides a by b and returns the result in a new number (aliases: <code>div()</code>)</li>
<li><code>Tpa.mod(a,b)</code> performs a mod b and returns the result in a new number</li>
<li><code>Tpa.frac(a)</code> takes the fractional part of a and returns it in a new number</li>
<li><code>Tpa.int(a)</code> takes the integer part of a and returns it in a new number</li>
<li><code>Tpa.abs(a)</code> takes the absolute value of a and returns it in a new number</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>var a=Tpa(5);
var b=Tpa(12.5,false);
console.log(Tpa.add(a,b).value());        // 17
console.log(Tpa.subtract(a,b).value());   // -7
console.log(Tpa.multiply(a,b).value());   // 60
console.log(Tpa.divide(b,a).toFraction());// '2 25/50'
console.log(Tpa.mod(a,b).value());        // 5
console.log(Tpa.frac(b).value());         // 0.5
console.log(Tpa.int(b).value());          // 12
console.log(Tpa.abs(-23).value());        // 23</code></pre><p>Note that for methods that take two arguments the first one dictates whether the result is integer or fractional. Thus the subtraction of 12.5 from 5 yields 7 as the operation is only working on integer parts. As opposed to the division that takes the type of b which is fractional.</p>
<h3>Performance</h3><p>I invested some effort in ensuring speed of operations. I have performed extensive comparisons with other libraries and can confidently say that this library is orders of magnitude faster in many areas. I have measured performance against two &quot;competitors&quot; for add, subtract, multiply and divide using numbers of various sizes ranging from a few decimal digits long to tens of thousands. Performance can also vary according to the order in which these numbers are presented. I have optimised in all these permutations and I have detailed timings for each. I present here a short summary (this all for integer values only):</p>
<h5>Addition &amp; subtraction</h5><ul>
<li>Around 5 million per second for either number &lt; 500 digits</li>
<li>Around 1 million per second for both numbers in the region of 1,000 digits</li>
<li>Around 150 thousand per second for both numbers in the region of 10,000 digits</li>
</ul>
<h5>Multiplication</h5><ul>
<li>Around 10 million per second for small numbers (&lt;10 digits)</li>
<li>Around 1 million per second for both numbers in the region of 25 digits</li>
<li>Around 1/2 million per second for both numbers in the region of 100 digits</li>
<li>Around 10 thousand per second for both numbers in the region of 1,000 digits</li>
<li>Around 150 per second for both numbers in the region of 10,000 digits</li>
</ul>
<h5>Division</h5><ul>
<li>Around 2-3 million per second for both numbers &lt; 25 digits</li>
<li>Around 1 million per second for both numbers in &lt; 100 digits</li>
<li>Around 300 thousand per second dividing 1,000 digit numbers by &lt;8 digit numbers</li>
<li>Around 40 thousand per second dividing 10,000 digit numbers by &lt;8 digit numbers</li>
<li>Around 15 thousand per second for dividing 1,000 digit numbers by 100 digit numbers</li>
<li>Around 1 thousand per second for dividing 10,000 digit numbers by 100 digit numbers</li>
<li>Around 250 per second for dividing 10,000 digit numbers by 1,000 digit numbers</li>
</ul>
<p>See <code>performance.txt</code> for full details of a test that compared this library (referred to as <code>Dom</code>) with two others (referred to <code>Alex</code> and <code>Mike</code>).</p>
<h3>Method index</h3><p>Construction and mutators take numbers as parameters in the following forms:</p>
<ol>
<li>Tpa object</li>
<li>Javascript number</li>
<li>Javascript string (decimal or fractional format)</li>
</ol>
<h5>Construction &amp; setting</h5><ul>
<li><code>new Tpa()</code> or <code>Tpa()</code></li>
<li><code>set()</code></li>
</ul>
<h5>Mutators</h5><ul>
<li><p>Unary</p>
<ul>
<li><code>frac()</code></li>
<li><code>int()</code></li>
<li><code>abs()</code></li>
<li><code>makeInteger()</code></li>
<li><code>makeFractional()</code></li>
</ul>
</li>
<li><p>Binary</p>
<ul>
<li><code>add()</code> or <code>plus()</code></li>
<li><code>subtract()</code> or <code>sub()</code> or <code>minus()</code></li>
<li><code>multiply()</code> or <code>mult()</code> or <code>times()</code></li>
<li><code>divide()</code> or <code>div()</code></li>
<li><code>mod()</code></li>
</ul>
</li>
</ul>
<h5>Enquirers</h5><ul>
<li>Unary<ul>
<li><code>sign()</code></li>
<li><code>hasFraction()</code></li>
<li><code>isZero()</code></li>
<li><code>isPositive()</code></li>
<li><code>isNegative()</code></li>
<li><code>isInteger()</code></li>
<li><code>isFractional()</code></li>
</ul>
</li>
<li>Binary<ul>
<li><code>lt()</code></li>
<li><code>lte()</code></li>
<li><code>gt()</code></li>
<li><code>gte()</code></li>
<li><code>eq()</code></li>
</ul>
</li>
</ul>
<h5>Output</h5><ul>
<li><code>toDecimal()</code> or <code>toString()</code></li>
<li><code>toFraction()</code></li>
<li><code>value()</code></li>
</ul>
<h5>Miscellaneous</h5><ul>
<li><code>simplify()</code></li>
</ul>
<p>Note that all mutators are available as static methods to preserve the original value as per this example</p>
<pre class="prettyprint source lang-javascript"><code>var x=Tpa(100);
var y=Tpa(50);
Tpa.divide(x,y);         // Returns a new number = x/y, x and y remain unchanged
x.divide(y);             // Returns x having been divided by y, only y remains unchanged</code></pre></article>
    </section>









<section>

<header>
    
        <h2>tpa.js</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><p>The complete code for Total Precision Arithmetic</p></div>
        

        


<dl class="details">

    
    <dt class="tag-version">Version:</dt>
    <dd class="tag-version"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    
    <dt class="tag-author">Author:</dt>
    <dd class="tag-author">
        <ul>
            <li>Dominic Thwaites</li>
        </ul>
    </dd>
    

    
    <dt class="tag-copyright">Copyright:</dt>
    <dd class="tag-copyright"><ul class="dummy"><li>(c) 2016 Dominic Thwaites dominicthwaites@mac.com</li></ul></dd>
    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="tpa.js.html">tpa.js</a>, <a href="tpa.js.html#line1">line 1</a>
    </li></ul></dd>
    

    

    

    
</dl>


        
    
    </div>

    

    

    

     

    

    

    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DJT-Tpa.html">Tpa</a></li><li><a href="TPA-N.html">N</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Apr 01 2016 14:03:34 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>