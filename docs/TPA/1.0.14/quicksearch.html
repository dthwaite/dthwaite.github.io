<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"N.js.html":{"id":"N.js.html","title":"Source: N.js","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Source: N.js /** * @file An internal module to store large integers for Total Precision Arithmetic * @author Dominic Thwaites * @copyright (c) 2016 Dominic Thwaites dominicthwaites@mac.com * @licence MIT * @module N */ module.exports=(/** @lends module:N*/function() { 'use strict'; /** * The built in error object. * @external Error * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error} */ // These are effectively constants - but they are changed for testing purposes var BASE=Math.pow(2,25); // The BASE to which numbers are stored var ROOTBASE=Math.floor(Math.sqrt(BASE)); // The square root of BASE var SQUAREBASE=Math.pow(BASE,2); // The square of the BASE - i.e. the maximum number able to be expressed accurately within a digit /** * The error message given when passing an invlaid initial value for a new number * * @const */ var INPUT_ERROR_MESSAGE='Number initialisation parameter badly formed'; /** * N is the core vehicle to store and manipulate arbitrarily long integers * * This class is not intended for external use and is *only* used internally by the TPA class. It does not form any part of the TPA API. It is documented here for developer convenience and interest. The minified browser build gives no access to this class except except via the internals of Tpa objects * * For efficiency reasons many methods do not have error checking or may make assumptions about the state of the number. * Any assumptions, however, are documented. * * @param {(Number|String|module:N~N)} [initialValue] The initial value assigned to this number. * This may be a JS numeric value, a string or another N instance. If numeric, any fractional part is ignored. * If string it may only contain digits starting with an optional + or - sign. If N, the new N will be a duplicate. * @constructor * @throws {external:Error} If parameter passed is not one of the above or is badly formed. */ var N=function(initialValue) { var i; if (this instanceof N) { if (arguments.length==0) { this.digits=[]; this.safemaximum=0; } else { if (initialValue instanceof N) { this.digits = new Array(initialValue.digits.length); for (i = this.digits.length - 1; i &gt;= 0; i--) this.digits[i] = initialValue.digits[i]; this.safemaximum = initialValue.safemaximum; } else { if (typeof initialValue == 'number') { if (isNaN(initialValue)) throw new Error(INPUT_ERROR_MESSAGE); else this.set(Math.trunc(initialValue)); } else { if (typeof initialValue == 'string') { var sign = initialValue[0] == '-' ? -1 : 1; this.digits=[]; this.safemaximum=0; for (i = (initialValue[0] == '-' || initialValue[0] == '+' ? 1 : 0); i &lt; initialValue.length &amp;&amp; /^\\d$/.test(initialValue[i]); i++) { this._digitMultiplyWithAdd(10, sign * parseInt(initialValue[i])); } if (i != initialValue.length) throw new Error(INPUT_ERROR_MESSAGE); } else throw new Error(INPUT_ERROR_MESSAGE); } } } } else { if (typeof initialValue=='undefined') return new N(); else return new N(initialValue); } }; // The build process will remove these methods if (typeof PRODUCTION==='undefined') { /** * Sets the BASE to which numbers are internally represented. * * This should *only* be set for experimentation and testing purposes. * Any existing instances of Tpa will become corrupt or invalid once the base is changed. * In the browser version this method is not available. * Safe rule: Don't call this set method! * * @param {Number} base The new BASE for number internal representation */ N.setBASE = function(base) { BASE = base; ROOTBASE = Math.floor(Math.sqrt(BASE)); SQUAREBASE = Math.pow(BASE, 2); }; /** * The BASE to which all numbers are stored. * * This is preset to 2^25 which is the optimal size. * However, it may be lower (not higher!) in order to test the integrity of internal representation and manipulation of numbers. * In the browser version this method is not available. * * @returns {Number} */ N.getBASE = function() { return BASE; }; } /** * Ensures that all digits of this number are less than the BASE * * Internal representation allows for digits to exceed BASE. Normalisation * is necessary where an impending operation depends on this not being the case. * Note also that normalisation does *not* remove negative digits that are * also permitted. Again, for some operations, negative digits are undesired * and the positivise method is required to remove them. * * @see #positivise * @param {Boolean} [noReduction=false] set to true if we wish to keep any trailing zero digits * @returns {module:N~N} This number for chaining purposes */ N.prototype.normalise=function(noReduction) { if (this.safemaximum&gt;=BASE) { for (var i = 0, carry = 0; i &lt; this.digits.length; i++) { carry += this.digits[i]; this.digits[i] = carry % BASE; carry = Math.trunc(carry / BASE); } if (carry) this.digits[this.digits.length] = carry; this.safemaximum = BASE-1; } if (noReduction) return this; while (this.digits.length&gt;0 &amp;&amp; this.digits[this.digits.length-1]==0) this.digits.length--; return this; }; /** * Removes any negative digits by carry over. * * This function should *only* be called once it is established that the number is both positive overall * and is normalised. * @see #abs * @see #normalise */ N.prototype.positivise=function() { for (var i=0; i&lt;this.digits.length; i++) { if (this.digits[i]&lt;0) { this.digits[i]+=BASE; this.digits[i+1]--; } } while (this.digits.length&gt;0 &amp;&amp; this.digits[this.digits.length-1]==0) this.digits.length--; return this; }; /** * @returns {Boolean} `true` if this number is negative, false if zero or positive */ N.prototype.isNegative=function() { if (this.isZero()) return false; return this.digits[this.digits.length-1]&lt;0; }; /** * @returns {Boolean} `true` if this number is zero */ N.prototype.isZero=function() { return this.normalise().digits.length==0; }; /** * @returns {Boolean} `true` if this number is positive, false if zero or negative */ N.prototype.isPositive=function() { if (this.isZero()) return false; return this.digits[this.digits.length-1]&gt;0; }; /** * @returns {Number} The least significant digit of the number or 0 if zero */ N.prototype.lsb=function() { return this.isZero() ? 0 : (BASE+this.digits[0])%BASE; }; /** * Resets number to zero * * @returns {module:N~N} This number for chaining purposes */ N.prototype.reset=function() { this.digits=[]; this.safemaximum=0; return this; }; /** * Checks for divisibility. * * The divisor *must* be positive and less than the BASE * * @param {Number} testDivisor The number to test as a factor of this number * @return {Boolean} `true` if this number is divisible by the test-divisor */ N.prototype.isDivisibleBy=function(testDivisor) { if (testDivisor&lt;BASE) { for (var i = this.digits.length - 1, temp = 0; i &gt;= 0; i--) temp = (temp % testDivisor) * BASE + this.digits[i]; return temp % testDivisor == 0; } }; /** * Sets a new numeric value into this number * * @param {Number} newValue As per instantiation, setting Tpa with a JS native number is subject to accuracy constraints * @return {module:N~N} This number for chaining purposes */ N.prototype.set=function(newValue) { this.digits=[]; this.safemaximum=0; for (var i=0; newValue!=0; i++) { this.digits[i]=newValue%BASE; newValue=Math.trunc(newValue/BASE); } this.safemaximum=BASE-1; return this; }; /** * Gets the numeric value of this number * * The JS native number returned is subject to accuracy constraints and thus this method is only useful * as an indicator. Indeed, for very large numbers `infinity` can be returned. * * @return {Number} The value of this number accurate to within the bounds of JS native floating point number */ N.prototype.value=function() { for (var i=this.digits.length- 1, result=0; i&gt;=0; i--) result+=(this.digits[i]*Math.pow(BASE,i)); return result; }; /** * Compares two numbers * * *Note* This function can only be called when both numbers are positivised (and hence normalised) * * @see #positivise * @param {module:N~N} comparison The number to compare with this number * @return {number} 0 if equal, -1 if this &lt; comparison, +1 if this &gt; comparison */ N.prototype.compare=function(comparison) { if (this.digits.length&gt; comparison.digits.length) return 1; if (this.digits.length&lt; comparison.digits.length) return -1; for (var i= this.digits.length-1; i&gt;=0; i--) { if (this.digits[i]&gt; comparison.digits[i]) return 1; if (this.digits[i]&lt; comparison.digits[i]) return -1; } return 0; }; /** * Create a positive version of the number given * * @param {module:N~N} number The number to copy and make positive * @return {module:N~N} A new number that is the positive version of number */ N.abs=function(number) { return new N(number).abs(); }; /** * Make this number positive * * @return {module:N~N} This number for chaining purposes */ N.prototype.abs=function() { if (this.isNegative()) this.negate(); return this; }; /** * Addition * * @param {module:N~N} number The number to add to this number * @return {module:N~N} This number for chaining purposes */ N.prototype.add=function(number) { var i; this.safemaximum=this.safemaximum+number.safemaximum; if (this.safemaximum&gt;=SQUAREBASE) this.normalise(); var len=this.digits.length; if (number.digits.length&gt;len) { this.digits.length=number.digits.length; for (i = len; i &lt; number.digits.length; i++) this.digits[i] = number.digits[i]; } for (i=Math.min(len,number.digits.length)-1; i&gt;=0; i--) this.digits[i]+=number.digits[i]; return this; }; /** * Make this number the opposite sign * * If the number is positive it will be made negative, if negative it will be made positive * * @return {module:N~N} This number for chaining purposes */ N.prototype.negate=function() { for (var i=0; i&lt;this.digits.length; i++) this.digits[i]=-this.digits[i]; return this; }; /** * Subtraction * * @param {module:N~N} number The number to subtract from this number * @return {module:N~N} This number for chaining purposes */ N.prototype.subtract=function(number) { var i; this.safemaximum=this.safemaximum+number.safemaximum; if (this.safemaximum&gt;=SQUAREBASE) this.normalise(); var len=this.digits.length; if (number.digits.length&gt;len) { this.digits.length=number.digits.length; for (i = len; i &lt; number.digits.length; i++) this.digits[i] = -number.digits[i]; } for (i=Math.min(len,number.digits.length)-1; i&gt;=0; i--) this.digits[i]-=number.digits[i]; return this; }; /** * Multiplication * * @param {module:N~N} number The number to multiply this number * @return {module:N~N} This number for chaining purposes */ N.prototype.multiply=function(number) { var i; if (number.digits.length==0 || this.digits.length==0) return this.reset(); if (number.digits.length==1) { var m=number.digits[0]; this.safemaximum=this.safemaximum*Math.abs(m); if (this.safemaximum&lt;SQUAREBASE) { for (i = this.digits.length - 1; i &gt;= 0; i--) this.digits[i] *= m; } else this._digitMultiplyWithAdd(m,0); return this; } if (number.safemaximum&gt;=BASE) number.normalise(); if (this.safemaximum&gt;=BASE) this.normalise(); var operand=number.digits; var original=this.digits; this.digits=new Array(original.length+operand.length-1); for (i=0; i&lt;this.digits.length; i++) this.digits[i]=0; if (original.length&gt;3 &amp;&amp; operand.length&gt;3) return this._rapidMultiplication(original,operand,true) ._digitMultiplyWithAdd(ROOTBASE,0) ._rapidMultiplication(original,operand,false); else return this._basicMultiplication(original,operand); }; /** * Multiplication by a single digit * * The number provided must be less than BASE * * @param {Number} digit The number to multiply with * @return {module:N~N} This number for chaining purposes */ N.prototype.digitMultiply=function(digit) { return this._digitMultiplyWithAdd(digit,0); }; /** * Sets a number to a random value that is roughly the number of decimal digits given * * @param {Number} digits The number of decimal digits required * @return {module:N~N} This number for chaining purposes */ N.prototype.random=function(digits) { this.reset(); var digitsPerElement = Math.log(BASE) / Math.log(10); for (var i=0; digits &gt; digitsPerElement; i++) { this.digits[i]=Math.trunc(Math.random() * BASE); digits -= digitsPerElement; } this.digits[i]=Math.trunc((1+Math.random()) * Math.pow(10, digits)); this.safemaximum=BASE-1; return this; }; /** * The quotient of this number after dividing it by the number given * * @param {module:N~N} number The divisor * @return {module:N~N} This number for chaining purposes */ N.prototype.quotient=function(number) { this.divide(number); return this; }; /** * Division * * @param {module:N~N} number The number to divide into this number * @return {module:N~N} The remainder. *Note:* This number is not returned, unlike most other mutation operations * @throws {Error} If divisor is zero */ N.prototype.divide=function(number) { var i, j; var remainder=new N(); // Normalise our numbers if (number.safemaximum&gt;=BASE) number.normalise(); if (this.safemaximum&gt;=BASE) this.normalise(); // Check for zero if (this.digits.length==0) return remainder; if (number.digits.length==0) throw new Error('Attempt to divide by zero'); // If dividing by a single digit we have a quick way of doing this if (number.digits.length==1) return remainder.set(this.digitDivide(number.digits[0])); // Get the sign of our numbers and prepare them for long division var s1=Math.sign(this.digits[this.digits.length-1]),s2=Math.sign(number.digits[number.digits.length-1]); if (s1&lt;0) this.abs().positivise(); else this.positivise(); if (s2&lt;0) number.abs().positivise(); else number.positivise(); var compare=this.compare(number); switch (compare) { case -1: // numerator &lt; denominator; easy remainder=new N(this); this.reset(); break; case 0: // numerator==denominator; even easier this.set(1); break; case 1: // numerator&gt;denominator; trickier // Load up our remainder to close to the size of the denominator var numDigits=number.digits; var remDigits=remainder.digits=this.digits.slice(this.digits.length-number.digits.length); remainder.safemaximum=this.safemaximum; this.digits.length-=remDigits.length; var difference; // For each remaining digit in the numerator we get the digit that represents one step of the long division for (i = this.digits.length; i &gt;= 0; i--) { this.digits[i] = 0; while (remainder.compare(number) &gt;= 0) { // If our remainder is greater then denominator, then we get a good estimate of how much greater in difference difference = remDigits[remDigits.length - 1] * BASE + remDigits[remDigits.length - 2]; if (numDigits.length &lt; remDigits.length) difference = Math.max(1, Math.trunc(difference / (numDigits[numDigits.length - 1] + (numDigits[numDigits.length - 2] + 1)/BASE))); else difference = Math.max(1, Math.trunc(difference / (numDigits[numDigits.length - 1] * BASE + numDigits[numDigits.length - 2] + 1))); // Accumulate the difference and reduce the remainder by that number of denominators ... and then compare again this.digits[i] += difference; remainder._subtractMultiple(numDigits, difference); // More than likely our estimate was good and our remainder now stands at below the denominator, but we cant be sure... } if (i&gt;0) { // Considerably faster than Array.unshift() !!! for (j=remDigits.length; j&gt;0; j--) remDigits[j]=remDigits[j-1]; remDigits[0]=this.digits[i-1]; } } } if (s1*s2&lt;0) { // Set our results negative if our original numbers had different signs this.negate(); remainder.negate(); } while (this.digits.length&gt;0 &amp;&amp; this.digits[this.digits.length-1]==0) this.digits.length--; return remainder; // Returns the remainder - the 'this' number now contains the quotient }; /** * Division by a single digit * * The number provided must be less than BASE * * @param {Number} digit The number to multiply with * @return {Number} The remainder */ N.prototype.digitDivide=function(digit) { var temp; for (var i = this.digits.length - 1,overflow=0; i &gt;= 0; i--) { temp = overflow * BASE + this.digits[i]; this.digits[i] = Math.trunc(temp / digit); overflow = temp % digit; } while (this.digits.length&gt;0 &amp;&amp; this.digits[this.digits.length-1]==0) this.digits.length--; this.safemaximum=BASE-1; return overflow; }; /** * Decimal value of this number * * @return {String} The full decimal representation of this number */ N.prototype.toString=function() { var result=''; var test=new N(this).abs().normalise().positivise(); while (!test.isZero()) result=test.divide(N.TEN).lsb()+result; if (result.length==0) result='0'; if (this.isNegative()) result='-'+result; return result; }; // A low level routine to multiply this number by a small number (&lt;BASE) with // a carry digit to be added at the start N.prototype._digitMultiplyWithAdd=function(multiplier,digit) { if (this.safemaximum&gt;=BASE) this.normalise(true); for (var i=0; i&lt;this.digits.length; i++) { digit+=(this.digits[i]*multiplier); this.digits[i]=digit%BASE; digit=Math.trunc(digit/BASE); } if (digit) this.digits[this.digits.length]=digit; this.safemaximum=BASE-1; return this; }; // A low level routine to multiply two numbers and accrue them in to this number // It is assumed that this number has been reset to contain the required number // of zero digits. N.prototype._basicMultiplication=function(a,b) { if (a.length&gt; b.length) {var c=a; a=b; b=c;} for (var i= 0,j= 1,aDigit= 0,carry=0; i&lt;a.length; i++) { aDigit=a[i]%BASE; for (j= 0,carry=0; j&lt;b.length; j++) { carry+=(aDigit * b[j]+this.digits[i+j]); this.digits[i+j]=carry%BASE; carry = Math.trunc(carry / BASE); } if (carry) this.digits[i+j]=carry; } this.safemaximum=BASE-1; return this; }; // A low level routine to part-multiply two numbers. // This semi-multiplication takes only half of each multicand number to avoid carry processing // For large numbers this makes for greater efficency. msb tells us which half of the multicand to take. N.prototype._rapidMultiplication=function(a,b,msb) { var q; if (a.length&gt; b.length) {var c=a; a=b; b=c;} for (var i= a.length-1; i&gt;=0; i--) { if (msb) q=Math.trunc(a[i]/ROOTBASE); else q=a[i]%ROOTBASE; if (q!=0) for (var j = b.length - 1; j &gt;= 0; j--) this.digits[i + j] += q * b[j]; } this.safemaximum*=ROOTBASE; return this; }; // A low level routing to subtract a multiple of the given array of digits. This is used for efficient division // And requires that it yields a non-negative result N.prototype._subtractMultiple=function(number,digit) { for (var i = 0,remainder= 0,modulus=0; i &lt; number.length; i++) { remainder+=(number[i] * digit); modulus = remainder % BASE; remainder = Math.trunc(remainder / BASE); if (modulus &gt; this.digits[i]) { this.digits[i] += (BASE - modulus); remainder++; } else this.digits[i] -= modulus; } if (remainder) this.digits[i]-=remainder; while (this.digits.length&gt;0 &amp;&amp; this.digits[this.digits.length-1]==0) this.digits.length--; }; //A rough estimate of the square root of a number used to test for prime factors N.prototype._roughSqrt=function() { var sqrt=new N(); if (this.digits.length&gt;0) { if (this.digits.length==1) sqrt.set(Math.ceil(Math.sqrt(this.digits[0]))); else { var msd=Math.ceil(Math.sqrt(this.digits[this.digits.length-1]*BASE+this.digits[this.digits.length-2]+1)); sqrt.digits=this.digits.slice(0,Math.trunc((this.digits.length-2)/2)); if (this.digits.length%2==1) msd*=Math.sqrt(BASE); sqrt.digits.push(msd%BASE); } } return sqrt; }; //Note that these constants are for convenience and must be used carefully so that they are not changed! N.ZERO=new N(); N.ONE=new N().set(1); N.TWO=new N().set(2); N.TEN=new N().set(10); // Prime number generator. This class is used to iterate through prime numbers in order to find // common factors to a fraction to allow us to simplify that fraction N.Primes=(function() { var primes=[2,3]; // cache of prime numbers // Instantiation sets up an iterator to start from the first prime (2) function Primes() { this.iterator=0; } // Calls to next() will deliver the next prime number. Primes.prototype.next=function() { if (this.iterator&lt;primes.length) return primes[this.iterator++]; var next=primes[primes.length-1]; do { // Find the next prime number, though abandon if greater than BASE next+=2; if (next&gt;=BASE) return 0; var sqrt = Math.sqrt(next); var prime=true; for (var i = 0; i &lt; primes.length &amp;&amp; primes[i]&lt;=sqrt; i++) { if (next%primes[i]==0) { prime = false; break; } } } while (!prime); // Store this new prime number for subsequent use primes.push(next); this.iterator++; return next; }; return Primes; })(); // A temporary number that is used in interim calculations to improve performance var temporary=new N(); N.temporary=function(number) { temporary.digits.length=number.digits.length; for (var i=0; i&lt;number.digits.length; i++) temporary.digits[i]=number.digits[i]; temporary.safemaximum=number.safemaximum; return temporary; }; return N; })(); × Search results Close "},"tpa.js.html":{"id":"tpa.js.html","title":"Source: tpa.js","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Source: tpa.js /** * @file The complete code for Total Precision Arithmetic * @author Dominic Thwaites * @copyright (c) 2016 Dominic Thwaites dominicthwaites@mac.com * @licence MIT * @module TPA */ module.exports = (/** @lends module:TPA*/function(globalObj) { //eslint-disable-line 'use strict'; /** * The error message given when passing an invalid initial value for a new number * * @const */ var INPUT_ERROR_MESSAGE='Number initialisation parameter badly formed'; /** * number of DPs to take from a numeric construction and to output with the value() method * * @const */ var VALUE_DECIMAL_PLACES=8; // Polyfill Math.trunc Math.trunc = Math.trunc || function(x) { return x &lt; 0 ? Math.ceil(x) : Math.floor(x); }; // Polyfill Math.sign Math.sign = Math.sign || function(x) { x = +x; // convert to a number if (x === 0 || isNaN(x)) { return x; } return x &gt; 0 ? 1 : -1; }; /** * Tpa stores and manipulates rational numbers with total precision * * @param {(number|string|module:TPA~Tpa)} [initialValue] Initial value to set this number. * 1. Numeric values are only represented to a precision of 8 decimal places and, in any case, are limited by the precision of a JS floating point number. To initialise a number with definite accuracy the string form is recommended. * 2. String values can be represented in decimal or fractional form. * * Decimal form: `&lt;+/-&gt;iii.ddd[rrr]` where `+/-` is optional, `iii` represents the integer part and `ddd` the decimal part with `[rrr]` representing an optional recurring decimal part * * Fractional form: `&lt;+/-&gt; iii nnn/ddd` where `+/-` is optional, `iii` represents the (optional) integer part, `nnn` the numerator and `ddd` the denominator. The fraction may be top heavy. * 3. Tpa instance causes this constructor to return a copy of it. * * Tpa may be called statically, in which case a new instance is still returned. * __Note well:__ If initialValue is itself a Tpa, then the same Tpa is returned *without* making a copy when called statically. * @param {boolean} [isInteger=true] Set to `false` to enable this number to represent fractions. * If the initialValue is fractional in any way then isInteger will default to `false`. * The initial setting of this number (integer or fractional) is always kept throughout its life unless the {@link makeFractional} or {@link makeInteger} methods are called to change it. * @see #makeFractional * @see #makeInteger * @example * var a=new Tpa(); // Creates a new number set to zero * var b=Tpa(20); // Creates a new number preset to 20 * var c=Tpa['0.[6]']; // Creates a new number preset to 2/3 * var d=new Tpa('2/3']; // Creates a new number preset to 2/3 * var e=new Tpa('-4 538/1284'); // Creates a new number preset to -4.4[19003115264797507788161993769470404984423676012461059] * var f=new Tpa(b); // Creates a new number preset to 20 * var g=Tpa(e); // Does NOT create a new number: Object g references Object f * var h=Tpa(false); // Creates a new number set to zero but is configured to represent fractions * var i=Tpa(100,false); // Creates a new number set to 100 but is configured to represent fractions * var j=Tpa(100.5,true); // Creates a new number set to 100 as we explicitly set it to be integer only and the fractional part is ignored * var k=Tpa('10 20/3',true); // Creates a new number set to 16 as we explicitly set it to be integer only and the fractional part is ignored * @constructor * @throws {external:Error} If the constructor parameters are not valid */ var Tpa=TPA; var N=require('./N.js'); // Utility function to return a remainder in standard form function standardRemainder(numerator,denominator) { return { numerator: numerator instanceof N ? numerator : new N(), denominator: denominator instanceof N ? denominator : new N(1) }; } // Constructor for a new Tpa function TPA(initial,integer) { // Logic to redirect a static call to return a new object if (!(this instanceof Tpa)) { // The only exception to the above is that if an instance of this class is passed in the static // call it will be returned with creating a new copy - so long as the type is the same (integer or not) if (initial instanceof Tpa &amp;&amp; (typeof integer != 'boolean' || integer == initial.integer)) return initial; switch (arguments.length) { case 0: return new Tpa(); case 1: return new Tpa(initial); default: return new Tpa(initial, integer); } } return this.set.apply(this,arguments); } /** * Sets this number to a new value * * Parameters passed are exactly those expected for construction of a new Tpa * * @param {(number|string|module:TPA~Tpa)} [initialValue] Initial value to set this number. * @param {boolean} [isInteger=true] Set to `false` to enable this number to represent fractions. * @return {module:TPA~Tpa} this number for chaining purposes */ Tpa.prototype.set=function(initialValue,isInteger) { var me = this; // Establish whether this instance is to be an integer only this.integer=true; if (typeof initialValue == 'boolean') this.integer=initialValue; if (typeof isInteger=='boolean') this.integer=isInteger; // If the constructor argument is an instance of this class then we return a copy of that instance if (initialValue instanceof Tpa) { this.number=new N(initialValue.number); if (!(typeof isInteger == 'boolean') &amp;&amp; initialValue.isFractional()) this.integer=false; if (!this.integer) { if (initialValue.isInteger()) this.remainder=standardRemainder(); else { this.remainder = { numerator: new N(initialValue.remainder.numerator), denominator: new N(initialValue.remainder.denominator) }; } } return this; } // If the constructor argument is a number then we preset this number with the number given if (typeof initialValue == 'number') { this.number=new N(initialValue); var denominator=Math.pow(10,VALUE_DECIMAL_PLACES); var numerator=Math.trunc((initialValue-Math.trunc(initialValue)).toFixed(VALUE_DECIMAL_PLACES)*denominator); // Note that the fractional part only takes 8 decimal places (as per VALUE_DECIMAL_PLACES) if (typeof isInteger!='boolean' || !this.integer) { if (typeof isInteger!='boolean') this.integer=numerator==0; while (numerator != 0 &amp;&amp; numerator % 10 == 0) { numerator/=10; denominator/=10; } if (numerator&gt;0 || !this.integer) { this.integer=false; this.remainder = { numerator: new N(numerator), denominator: new N(denominator) }; } } return this; } // Helper function to parse and create a fraction from an arbitrary number of decimal input representation // Note that the input is assumed to be &quot;clean&quot; function parseDecimal(input,sign) { me.remainder=standardRemainder(); for (var i= 0,recurring=null; i&lt;input.length; i++) { if (input[i]=='[' &amp;&amp; recurring===null) { recurring = { numerator: new N(me.remainder.numerator), denominator: new N(me.remainder.denominator) }; continue; } // The recurring section is mathematically achieved by subtracting the values at the start if (recurring &amp;&amp; input[i]==']') { me.remainder.numerator.subtract(recurring.numerator); me.remainder.denominator.subtract(recurring.denominator); return this; } me.remainder.denominator._digitMultiplyWithAdd(10, 0); me.remainder.numerator._digitMultiplyWithAdd(10, sign*parseInt(input[i])); } if (recurring) throw new Error(INPUT_ERROR_MESSAGE); } // Helper function to parse and create a fraction from a fractional input representation // Note that the input is assumed to be &quot;clean&quot; and that the regexps below will match function parseFraction(input) { var remainder=standardRemainder(new N(input.match(/^[\\+\\-]?\\d+/)[0]),new N(input.match(/\\/(\\d+)$/)[1])); if (remainder.denominator.isZero()) throw new Error(INPUT_ERROR_MESSAGE); if (!me.integer) { me.remainder=remainder; me._normaliseRemainder(); } else me.number.add(remainder.numerator.quotient(remainder.denominator)); } if (typeof initialValue == 'string') { initialValue=initialValue.trim(); if (!this.integer) this.remainder=standardRemainder(); if (initialValue.match(/^[\\+\\-]?\\d+\\/\\d+$/)) { // [+/-]nnn/nnn if (typeof isInteger != 'boolean') this.integer = false; this.number=new N(); parseFraction(initialValue); } else { var sign=initialValue[0]=='-'; if (initialValue.match(/^[\\+\\-]?\\d*/)===null) throw new Error(INPUT_ERROR_MESSAGE); this.number=new N(initialValue.match(/^[\\+\\-]?\\d*/)[0]); // [+/-]nnn if (initialValue.match(/^[\\+\\-]?\\d*$/)) return this; var match=initialValue.match(/^[\\+\\-]?\\d*([\\. ])/); if (match===null) throw new Error(INPUT_ERROR_MESSAGE); var remaining=initialValue.match(/^[\\+\\-]?\\d*[\\. ](.*)/)[1]; // [+/-]nnn[./ ] if (typeof isInteger != 'boolean') this.integer = false; switch (match[1]) { case '.': // Parse for decimal representation if (remaining.match(/^\\d*\\[?\\d+\\]?$/)===null) throw new Error(INPUT_ERROR_MESSAGE); if (!this.integer) parseDecimal(remaining,sign ? -1 : 1); break; case ' ': // Parse for fractional representation if (remaining.match(/^\\d+\\/\\d+$/)===null) throw new Error(INPUT_ERROR_MESSAGE); parseFraction((sign ? '-' : '')+remaining); break; } } return this; } if (typeof initialValue=='undefined' &amp;&amp; arguments.length&gt;0) throw new Error(INPUT_ERROR_MESSAGE); // If we had no initialiser, then set this number to zero this.number=new N(); if (!this.integer) this.remainder = standardRemainder(); return this; }; /** * Attempts a simplification of the remaining fraction * * Finding common factors (which would be prime numbers) is a time-consuming job. * Just as well, as otherwise most security mechanism (i.e. RSA) could be hacked in a jiffy. * So there is a limit to how large a fraction can be simplified. A realistic limit has therefore been * established here whereby prime factors can not exceed the BASE of the internal number representation. * Thus the highest prime explored is **33,554,393**. * Fractions that have their numerator larger than the square of this number may not be completely simplified - i.e. numbers of more than 15 digits. * * @param {number} [milliseconds=100] The maximum time in milliseconds to attempt simplification. 0 sets no limit. * @returns {boolean} `true` if simplification complete, `false` if there may still be some common factors left * @throws {external:Error} If an invalid limit is given */ Tpa.prototype.simplify=function(milliseconds) { // Preparations if (arguments.length&gt;0 &amp;&amp; (typeof milliseconds!='number' || isNaN(milliseconds))) throw new Error('Simplify() takes an optional numeric argument specifying the maximum number of millisecondsto process'); if (typeof milliseconds=='undefined') milliseconds=100; if (this.isInteger() || this.remainder.numerator.isZero()) return true; var isNegative=this.remainder.numerator.isNegative(); this.remainder.numerator.abs(); var limit= this.remainder.numerator._roughSqrt().value(); var primes=new N.Primes(); var start=new Date().getTime(); var factor=new N().set(1); // Loop through all the primes up to the square root of the numerator to test for common factors for (var prime= primes.next(); prime&gt;0 &amp;&amp; prime&lt;=limit; prime= primes.next()) { while (this.remainder.numerator.isDivisibleBy(prime)) { this.remainder.numerator.digitDivide(prime); if (this.remainder.denominator.isDivisibleBy(prime)) this.remainder.denominator.digitDivide(prime); else factor.digitMultiply(prime); } // Abort if our time is up if (new Date().getTime()-start&gt;milliseconds &amp;&amp; milliseconds&gt;0) { prime=0; break; } } // Clean up and set the factorised remainder accordingly var denominator=new N(this.remainder.denominator); var remainder=denominator.divide(this.remainder.numerator); if (remainder.isZero()) { this.remainder.denominator=denominator; this.remainder.numerator=factor; prime=1; } else this.remainder.numerator.multiply(factor); if (isNegative) this.remainder.numerator.negate(); // If prime is zero then we never got to finish return prime&gt;0; }; /** * Sets this number to hold integers only - removes any existing fractional part * * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.makeInteger=function() { this.integer=true; delete this.remainder; return this; }; /** * Sets this number to accept fractional amounts, if not already set * * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.makeFractional=function() { if (this.integer) { this.integer = false; this.remainder = standardRemainder(); } return this; }; /** * @returns {boolean} `true` if this number only represents integers */ Tpa.prototype.isInteger=function() { return this.integer; }; /** * @returns {boolean} `true` if this number is capable of representing fractions */ Tpa.prototype.isFractional=function() { return !this.integer; }; /** * @returns {boolean} `true` if this number is less than zero */ Tpa.prototype.isNegative=function() { if (this.isZero()) return false; if (this.number.isZero()) return this.remainder.numerator.isNegative(); else return this.number.isNegative(); }; /** * @returns {boolean} `true` if this number is greater than zero */ Tpa.prototype.isPositive=function() { if (this.isZero()) return false; if (this.number.isZero()) return this.remainder.numerator.isPositive(); else return this.number.isPositive(); }; /** * @returns {boolean} `true` if this number is equal to zero */ Tpa.prototype.isZero=function() { this._normaliseRemainder(); return this.number.isZero() &amp;&amp; (this.isInteger() || this.remainder.numerator.isZero()); }; /** * @returns {number} `-1` if this number is negative, `0` if zero or `1` if positive */ Tpa.prototype.sign=function() { if (this.isZero()) return 0; return this.isNegative() ? -1 : 1; }; /** * @returns {boolean} `true` if this number has a non-zero fractional part */ Tpa.prototype.hasFraction=function() { if (this.integer) return false; this._normaliseRemainder(); return !this.remainder.numerator.isZero(); }; /** * Gets the value of this number in standard JS floating point number * * Note that precision may well be lost in order to accommodate the limitations of floating point numbers. * For this reason, the number of decimal places is restricted to 8. * Tpa numbers can be so large as to cause an overflow on a floating point number to yield `infinity` * * @returns {number} A numeric value of this number */ Tpa.prototype.value=function() { var power=Math.pow(10,VALUE_DECIMAL_PLACES); if (this.integer) return this.number.value(); else { var numerator = new N(this.remainder.numerator).multiply(new N(power)); numerator.divide(this.remainder.denominator); return (this.number.value() + (numerator.value() / power).toFixed(VALUE_DECIMAL_PLACES)*1); } }; /** * Sets a number to hold fractional value * * @param {(number|string|module:TPA~Tpa)} number The number to copy * @returns {module:TPA~Tpa} A new number with the ability to hold fractions */ Tpa.makeFractional=function(number) { return new Tpa(number).makeFractional(); }; /** * Sets a number to hold integer values only * * @param {(number|string|module:TPA~Tpa)} number The number to copy * @returns {module:TPA~Tpa} A new number *without* the ability to hold fractions */ Tpa.makeInteger=function(number) { return new Tpa(number).makeInteger(); }; /** * Sets the integer part of a number to zero * * @param {(number|string|module:TPA~Tpa)} number The number from which the integer part is to be removed */ Tpa.frac=function(number) { return new Tpa(number).frac(); }; /** * Sets the fractional part of a number to zero * * @param {(number|string|module:TPA~Tpa)} number The number from which the fractional part is to be removed */ Tpa.int=function(number) { return new Tpa(number).int(); }; /** * Adds two numbers * * Aliases: `plus` * * @param {(number|string|module:TPA~Tpa)} a First number * @param {(number|string|module:TPA~Tpa)} b Second number * @returns {module:TPA~Tpa} a + b */ Tpa.add=function(a,b) { return new Tpa(a).add(b); }; /** * Subtracts two numbers * * Aliases: `minus`, `sub` * * @param {(number|string|module:TPA~Tpa)} a First number * @param {(number|string|module:TPA~Tpa)} b Second number * @returns {module:TPA~Tpa} a - b */ Tpa.subtract=function(a,b) { return new Tpa(a).subtract(b); }; /** * Multiplies two numbers * * Aliases: `mult`, `times` * * @param {(number|string|module:TPA~Tpa)} a First number * @param {(number|string|module:TPA~Tpa)} b Second number * @returns {module:TPA~Tpa} a * b */ Tpa.multiply=function(a,b) { return new Tpa(a).multiply(b); }; /** * Divides two numbers ( a / b ) * * Aliases: `div` * * @param {(number|string|module:TPA~Tpa)} a First number * @param {(number|string|module:TPA~Tpa)} b Second number * @returns {module:TPA~Tpa} a / b */ Tpa.divide=function(a,b) { return new Tpa(a).divide(b); }; /** * Modulus of two numbers * * Aliases: `mod` * * @param {(number|string|module:TPA~Tpa)} a First number * @param {(number|string|module:TPA~Tpa)} b Second number * @returns {module:TPA~Tpa} a mod b */ Tpa.modulus=function(a,b) { return new Tpa(a).mod(b); }; /** * Absolute value of a number * * @param {(number|string|module:TPA~Tpa)} n The number * @returns {module:TPA~Tpa} |n| */ Tpa.abs=function(n) { return new Tpa(n).abs(); }; /** * Creates a random number of an approximate number of decimal digits long * * @param {number} digits The number of decimal digits * @returns {module:TPA~Tpa} A new number set a a random value */ Tpa.random=function(digits) { if (typeof digits=='number' &amp;&amp; digits&gt;0) { var result=new Tpa(); result.number.random(digits); } else throw new Error('You must specify a positive number of decimal digits as an approximate size for this number'); return result; }; /** * Compares the given number with this number * * @param {(number|string|module:TPA~Tpa)} number The number to compare * @returns {number} `-1` if this number is less than the given number, `0` if equal, `1` if greater */ Tpa.prototype.compare=function(number) { function compare(a,b) { return N.abs(a).normalise().positivise().compare(N.abs(b).positivise().normalise()); } if (number===this) return 0; number = Tpa(number); this._normaliseRemainder(); number._normaliseRemainder(); if (this.sign()!=number.sign()) { if (this.sign()==0) return -number.sign(); else return this.sign(); } var result = compare(this.number,number.number); if (result == 0 &amp;&amp; this.isFractional()) { if (number.isFractional()) result=compare(new N(this.remainder.numerator).multiply(number.remainder.denominator),new N(this.remainder.denominator).multiply(number.remainder.numerator)); } return result; }; /** * @param {(number|string|module:TPA~Tpa)} number The number to compare * @returns {boolean} `true` if this number is less than the given number */ Tpa.prototype.lt=function(number) { return this.compare(number)==-1; }; /** * @param {(number|string|module:TPA~Tpa)} number The number to compare * @returns {boolean} `true` if this number is less than or equal to the given number */ Tpa.prototype.lte=function(number) { return this.compare(number)!=1; }; /** * @param {(number|string|module:TPA~Tpa)} number The number to compare * @returns {boolean} `true` if this number is greater than the given number */ Tpa.prototype.gt=function(number) { return this.compare(number)==1; }; /** * @param {(number|string|module:TPA~Tpa)} number The number to compare * @returns {boolean} `true` if this number is greater than or equal to the given number */ Tpa.prototype.gte=function(number) { return this.compare(number)!=-1; }; /** * @param {(number|string|module:TPA~Tpa)} number The number to compare * @returns {boolean} `true` if this number is equal to the given number */ Tpa.prototype.eq=function(number) { return this.compare(number)==0; }; /** * Sets the fractional part of this number to zero * * @return {(number|string|module:TPA~Tpa)} This number for chaining purposes */ Tpa.prototype.int=function() { if (!this.integer) this.remainder=standardRemainder(); return this; }; /** * Sets the integer part of this number to zero * * @return {(number|string|module:TPA~Tpa)} This number for chaining purposes */ Tpa.prototype.frac=function() { this._normaliseRemainder().number.reset(); return this; }; /** * Takes the absolute value of this number * * @return {(number|string|module:TPA~Tpa)} This number for chaining purposes */ Tpa.prototype.abs=function() { this.number.abs(); if (!this.integer) this.remainder.numerator.abs(); return this; }; /** * Multiply this number by the one given * * Aliases: `mult` * * If this number is fractional, then it will perform a full fractional multiplication. * If it is set as an integer then the multiplication will ignore any fractional part of the multiplier * * @param {(number|string|module:TPA~Tpa)} number The number to multiply by * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.multiply=function(number) { if (!(number instanceof TPA)) number=Tpa(number); if (!this.integer) { if (!number.integer) { this.remainder.numerator.multiply(N.temporary(number.remainder.denominator).multiply(number.number).add(number.remainder.numerator)) .add(N.temporary(number.remainder.numerator).multiply(this.number).multiply(this.remainder.denominator)); this.remainder.denominator.multiply(number.remainder.denominator); } else this.remainder.numerator.multiply(number.number); } this.number.multiply(number.number); return this; }; /** * Divide this number by the one given * * Aliases: `div` * * If this number is fractional, then it will perform a full fractional division. * If it is set as an integer then the division will ignore any fractional part of the divisor * * @param {(number|string|module:TPA~Tpa)} number The number to multiply by * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.divide=function(number) { if (!(number instanceof TPA)) number=Tpa(number); if (!this.integer) { if (!number.integer) { this.number.multiply(this.remainder.denominator).add(this.remainder.numerator).multiply(number.remainder.denominator); this.remainder.numerator =this.number.divide(this.remainder.denominator.multiply(N.temporary(number.number).multiply(number.remainder.denominator).add(number.remainder.numerator))); } else { this.number.multiply(this.remainder.denominator).add(this.remainder.numerator); this.remainder.numerator = this.number.divide(this.remainder.denominator.multiply(number.number)); } } else this.number.divide(number.number); return this; }; /** * Sets this number to the modulus of the number given * * Aliases: `mod` * * Fractional parts of either number are ignored - the modulus is based on the integer parts ony * * @param {(number|string|module:TPA~Tpa)} number The divisor number * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.modulus=function(number) { if (!(number instanceof TPA)) number=Tpa(number); this.number=this.number.divide(number.number); if (!this.integer) this.remainder=standardRemainder(); return this; }; /** * Subtracts the given number from this number * * Aliases: `sub`, `minus` * * If this number is fractional, then it will perform a full fractional subtraction. * If it is set as an integer then the subtraction will ignore any fractional part of the number to be subtracted * * @param {(number|string|module:TPA~Tpa)} number The number to subtract * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.subtract=function(number) { if (!(number instanceof TPA)) number=Tpa(number); this.number.subtract(number.number); if (!this.integer) { if (!number.integer &amp;&amp; !number.remainder.numerator.isZero()) { this.remainder.numerator.multiply(number.remainder.denominator).subtract(N.temporary(number.remainder.numerator).multiply(this.remainder.denominator)); this.remainder.denominator.multiply(number.remainder.denominator); } this._normaliseRemainder(); } return this; }; /** * Adds the given number to this number * * Aliases: `plus` * * If this number is fractional, then it will perform a full fractional addition. * If it is set as an integer then the addition will ignore any fractional part of the number to be added * * @param {(number|string|module:TPA~Tpa)} number The number to add * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype.add=function(number) { if (!(number instanceof TPA)) number=Tpa(number); this.number.add(number.number); if (!this.integer) { if (!number.integer &amp;&amp; !number.remainder.numerator.isZero()) { this.remainder.numerator.multiply(number.remainder.denominator).add(N.temporary(number.remainder.numerator).multiply(this.remainder.denominator)); this.remainder.denominator.multiply(number.remainder.denominator); } this._normaliseRemainder(); } return this; }; /** * Outputs a decimal representation of this number * * All Tpa numbers are rational and thus have a limited or recurring set of decimal places * Recurring decimals are notated in square brackets - e.g. 33.[3] for 33 and one third * If there are more decimals to output than the maximum requested the output is cut off and finishes with an ellipsis (...) * * @param {number} [maxDecimalPlaces=100] The maximum number of decimal places to give * @see #toString * @returns {string} The number in format: `[-]nnn.ddd[rrr]` */ Tpa.prototype.toDecimal=function(maxDecimalPlaces) { return typeof maxDecimalPlaces=='undefined' ? this.toString() : this.toString(maxDecimalPlaces); }; /** * Outputs the decimal representation of the integer part of this number only * * @returns {string} The number in decimal form: `[-]nnn` */ Tpa.prototype.toInteger=function() { this._normaliseRemainder(); return (this.isNegative() ? '-' : '')+N.abs(this.number).toString(); }; /** * Outputs this number in fractional representation: `[-]nnn nnn/nnn` * * @returns {string} The number in fractional form */ Tpa.prototype.toFraction=function() { var result=this.toInteger(); if (this.isFractional() &amp;&amp; !this.remainder.numerator.isZero()) { result=result+' '+ N.abs(this.remainder.numerator).toString(); result=result+'/'+this.remainder.denominator.toString(); } return result; }; /** * Outputs a decimal representation of this number * * All Tpa numbers are rational and thus have a limited or recurring set of decimal places * Recurring decimals are notated in square brackets - e.g. 33.[3] for 33 and one third * If there are more decimals to output than the maximum requested the result is cut off andends with an ellipsis (...) * * @param {number} [maxDecimalPlaces=100] The maximum number of decimal places to give * @see #toDecimal * @returns {string} The number in format: `[-]nnn.ddd[rrr]` */ Tpa.prototype.toString=function(maxdp) { if (typeof maxdp != 'number' || isNaN(maxdp)) { if (arguments.length&gt;0) throw new Error('toString() takes an optional parameter to specify the maximum DPs to output [default=100]'); else maxdp=100; } var result=this.toInteger(); if (this.isFractional() &amp;&amp; !this.remainder.numerator.isZero()) { result+='.'; var numeratorstore=[]; for (var numerator=new N(this.remainder.numerator).abs().normalise().positivise(),remainder=0; !numerator.isZero() &amp;&amp; maxdp&gt;0; maxdp--) { for (var i=numeratorstore.length-1; i&gt;=0; i--) { if (numeratorstore[i].compare(numerator)==0) break; } if (i&gt;=0) { result=result.substr(0,result.length+i-numeratorstore.length)+'['+result.substr(result.length+i-numeratorstore.length)+']'; break; } numeratorstore.push(new N(numerator)); remainder = numerator._digitMultiplyWithAdd(10, 0).divide(this.remainder.denominator); result+=numerator.lsb(); numerator=remainder; } if (maxdp==0 &amp;&amp; !numerator.isZero()) result=result+'...'; } return result; }; /** * Normalises the remainder - ensures the numerator is less than the denominator * * @private * @returns {module:TPA~Tpa} This number for chaining purposes */ Tpa.prototype._normaliseRemainder=function() { if (!this.integer) { var numerator = this.remainder.numerator.divide(this.remainder.denominator); this.number.add(this.remainder.numerator); this.remainder.numerator = numerator; if (this.remainder.numerator.isZero()) this.remainder.denominator.set(1); else { if (this.remainder.numerator.isNegative()) { if (this.number.isPositive()) { this.remainder.numerator.add(this.remainder.denominator); this.number.subtract(N.ONE); } } else { if (this.number.isNegative()) { this.remainder.numerator.subtract(this.remainder.denominator); this.number.add(N.ONE); } } } } return this; }; // Allow external access to the internal N class - for testing purposes only if (typeof PRODUCTION==='undefined') { Tpa.N = N; } // Aliases Tpa.plus=Tpa.add; Tpa.prototype.plus=Tpa.prototype.add; Tpa.minus=Tpa.subtract; Tpa.prototype.minus=Tpa.prototype.subtract; Tpa.sub=Tpa.subtract; Tpa.prototype.sub=Tpa.prototype.subtract; Tpa.times=Tpa.multiply; Tpa.prototype.times=Tpa.prototype.multiply; Tpa.mult=Tpa.multiply; Tpa.prototype.mult=Tpa.prototype.multiply; Tpa.div=Tpa.divide; Tpa.prototype.div=Tpa.prototype.divide; Tpa.mod=Tpa.modulus; Tpa.prototype.mod=Tpa.prototype.modulus; return Tpa; })(); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Modules Classes N Tpa × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Classes Classes N Tpa × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Externals Classes N Tpa × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error TPA 1.0.14 TPA - Total Precision Arithmetic tpa.js performs basic arithmetic operations with total precision.Available on GitHub, details on JSDocs. See it working: Demonstration The main features are: Simplicity - one library, add/subtract/multiply/divide Performance - optimised to perform operations reasonably fast (see below) Limitless - represents and operates on rational numbers of any size and precision Expressive - inputs/outputs numbers using decimal or fractional forms Quality - comprehensively tested and documented For a terse list of methods go to the end of this readme. The usage section below is more descriptive. There are many similar libraries available. I wrote this more as an exercise than anything else. Enjoy. Node.js:To install it:npm install TPA To see how to use it:npm docs TPA To code with it: var Tpa = require('Tpa'); var n=new Tpa('3 1/3'); console.log(n.toString()); // Outputs '3.[3]'Browser:To install it: Download tpa.min.js from GitHub or use their CDN for my latest version: v1.0.14 tpa.min.js is a UMD (Universal Module Definition) bundle with an export name of Tpa To see how to use it: To code with it: &lt;script src =&quot;tpa.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var n=new Tpa('3 1/3'); console.log(n.toString()); // Outputs '3.[3]' &lt;/script&gt;Development:Test:npm test Review Coverage (upon successful test):npm run coverage Lint (to ensure no eslint issues):npm run lint Build minified version for browser into lib/tpa.min.js:npm run build A note about performanceHow fast is this library compared to others? Good question. And tricky to answer. It all depends on the operation, the size of the numbers, whether they are fractional or not (many libraries just do integers), whether you call static or instance methods and your run time environment. I spent some time comparing and contrasting and there's no straight answer. Most of the time this library performs quite well in comparison. Sometimes wildy better than most, sometimes not so good and it's difficult to summarise. If performance is really important then you must do your own analysis specific to your environment and needs to then choose the fastest in your circumstance. If it's not that important then you could do a lot worse than choosing this one. I've focussed on delivering a healthy mix of the features listed earlier. It's not slow, by any means. UsageSet upvar n1=new Tpa(); // new integer set to zero var n2=new Tpa(123); // new integer set to 123 var n3=new Tpa(213.5); // new fraction set to 123.5 var n4=new Tpa('123'); // new integer set to 123 var n5=new Tpa('123.3[3]'); // new fraction set to 123 1/3 var n6=new Tpa('123 1/3'); // new fraction set to 123 1/3 var n7=new Tpa('-4 538/1284'); // new fraction set to to -4.41900311... var n8=new Tpa('-.2[512]'); // new fraction n8.set(-9); // Sets an existing number to a new value n8.set(); // resets an existing number to zero n8.set('-4 538/1284'); // resets an existing number 4.41900311... n8.set(n2); // Sets an existing number to equal another (takes a copy)As can be seen above, setting a number with a string representation is the best way as you can express any rational number with complete accuracy using either a decimal form (with optional recurring digits) or a fractional form. OutputsNumbers can be output in decimal (toDecimal()) or fractional (toFraction()) form. Decimal places are limited to 100 unless specified in the toString() or toDecimal() methods. console.log(n1.toString()); // '0' console.log(n2.toString()); // '123' console.log(n2.value()); // 123.0 console.log(n3.toString()); // '123.5' console.log(n3.toDecimal()); // '123.5' (alias for toString()) console.log(n3.toFraction()); // '123 5/10' n3.simplify(); console.log(n3.toFraction()); // '123 1/2' console.log(n5.toDecimal()); // '123.[3] console.log(n5.toFraction()); // '123 30/90' console.log(n7.toFraction()); // '-4 538/1284' n7.simplify(); console.log(n7.toFraction()); // '-4 269/642' console.log(n7.toDecimal()); // '-4.4[19003115264797507788161993769470404984423676012461059]' console.log(n7.toDecimal(20)); // '-4.41900311526479750778...' (limit dp's to 20)Note that there is a value() method that gives the number as a javascript floating point number. This will clearly be an approximation in many cases. OperationsMethods add(), subtract(), multiply() and divide() all operate in-situ on the number on which they are called. They return the number to allow for chaining of operations. Each takes a parameter that may either be an existing Tpa object (which is not changed) or a number or string that is a valid representation. Aliases for the above are: plus(), sub(), minus(), mult(), times(), div(). console.log(n2.add(n2).toString()); // '246' console.log(n2.subtract(123).toString()); // '123' n2.subtract('200'); console.log(n2.toDecimal()); // '-77' n2.add(new Tpa(200)); console.log(n2.toDecimal()); // '123' console.log(n5.multiply(n3).toString()); // '26331.[6]' (123 3/9 * 123.5) n5.divide(n3); console.log(n5.toString()); // '123.[3]' n5.subtract('23 1/3').divide(2).add('48 2/1').divide(-100); console.log(n5.toString()); // '-1'Integer and FractionsTpa numbers are declared either integer or fractional. If integer then all operations performed on them will only use the integer part of their operands. Whether a number is integer or fractional is inferred from its initialisation. But you can force the issue by passing true (for integer) or false (for fractional) as an additional parameter to the Tpa constructor var a=new Tpa(3); // Constructs a to be integer var b=new Tpa(7.8); // Constructs b to be fractional a.add(b); console.log(a.toString()); // '10' (a is an integer and ignores fractional operands) var c=new Tpa(3,false); // Explicitly set a to be fractional c.add(b); console.log(c.toString()); // '10.8' (c is fractional and so operates on fractional operands) var d=new Tpa(b,true); // Explicitly set d to be integer console.log(d.toString()); // '7' (d was constructed to ignore any fractional part) var e=new Tpa('23 100/23',true); // Explicitly set e to be integer console.log(e.value()); // 27 (e took on the integer evaluation of the initialising string) console.log(e.set(3,false).value()); // Sets an existing number to a new value and to be fractionalYou can find out what type a number is with the isInteger() and isFractional() methods and you can convert a number to one or other representation with the makeInteger() and makeFractional() methods: var a=new Tpa('33 2/3'); console.log(a.isInteger()); // false console.log(a.makeInteger().value()); // 33 console.log(a.isInteger()); // true var b=new Tpa(10); console.log(b.makeFractional().subtract(11.5).value()); // -1.5 console.log(b.isFractional()); // true console.log(b.makeInteger().toDecimal()); // '-1'The reason Tpa makes a distinction is that a common requirement is simply to deal with integers. Processing fractions for the four main operations is a significant overhead. In fact it can quite quickly lead to massive numerators and denominators in fractional parts of numbers in order to maintain total precision. Keep this in mind. Fractions are never automatically simplified. However, the simplify() method makes its best attempt to simplify the fractional part of a number. Reducing a very large fraction is compute intensive (just as well because most encryption mechanisms rely on this fact!) as it essentially involves trying to find common prime factors. var n=new Tpa('1/3'); n.multiply('3/5').multiply('9/7').multiply('23/45').multiply('12 45/87').divide('99.75'); console.log(n.toString(25)); // '0.0164924626838031038186599...' console.log(n.toFraction()); // '0 67626900/4100473125' console.log(n.simplify()); // true - indicates that simplification was fully achieved console.log(n.toFraction()); // '0 11132/674975' n=new Tpa('234789789167435342333343/4239123411142533478912'); console.log(n.simplify()); // false - defaults to 100 ms which is probably not enough time console.log(n.toFraction()); // '55 1638001554596000993183/4239123411142533478912' console.log(n.simplify(0)); // true - achieved full simplification console.log(n.toFraction()); // '55 1638001554596000993183/4239123411142533478912'It is often the case that the fractional form is more terse than a decimal read out. The decimal form of the number resulting from that chain of computations has a recurring decimal section of 252 digits while the simplified fraction involves considerably less digits. The simplify() method does not look for any common prime factors above 33,554,393. It also limits its computation to 100 milliseconds. You can bypass this by passing in the number of milliseconds you are prepared to wait or 0 to indicate no limit. The system builds up its own inventory of prime numbers and it may take several seconds to simplify the first time (assuming you permit it) as it creates this inventory. But subsequent simplifications will generally be achieved within one second. simplify() returns true if the fraction has been fully simplified otherwise it may or may not have been fully simplified as either the fraction may have a common factor above 33,554,393 or time has run out. ComparisonsThere are a selection of comparison methods, namely: isZero(), isPositive(), isNegative(), lt(), lte(), gt(), gte() and eq() var a=Tpa(3); var b=Tpa(3.5); var c=Tpa('4 1/4'); var d=Tpa('3 5/4'); var f=Tpa(); console.log(a.isZero()); // false console.log(a.isPositive()); // true console.log(f.isPositive()); // false (it's zero) console.log(b.isNegative()); // false console.log(a.lt(b)); // false (a is an integer and ignores fractional operands) console.log(a.lt(c)); // true console.log(d.lte(c)); // true (they are equal) console.log(d.gte(c)); // true (ditto) console.log(d.gt(c)); // false console.log(d.eq(c)); // trueOther methods sign() returns -1, 0 or 1 if the number is negative, zero or positive respectively hasFraction() return true if the number has a non zero fractional part frac() removes the integer value from the number int() removes the fractional value from the number modulus() set this number to the modulus of the number passed in abs() set this number to its absolute value console.log(Tpa(-3).sign()); // -1 console.log(Tpa(3.3).hasFraction()); // true console.log(Tpa('-3 1/3').frac().toFraction()); // '-0 1/3' console.log(Tpa('-3 1/3').int().toFraction()); // '-3' console.log(Tpa(22).modulus(3).toString()); // '1' console.log(Tpa(-33.5).abs().value()); // 33.5Static methodsTypically the arithmetical operations change the number on which they are called. Alternatively you can choose to not mutate existing numbers to return a new number which is the result of the operation. This is achieved with static functions as follows: Tpa.add(a,b) adds a and b and returns the result in a new number (aliases: plus()) Tpa.subtract(a,b) subtracts b from a and returns the result in a new number (aliases: sub() &amp; minus()) Tpa.multiply(a,b) multiplies two numbers and returns the result in a new number (aliases: times() &amp; mult()) Tpa.divide(a,b) divides a by b and returns the result in a new number (aliases: div()) Tpa.modulus(a,b) performs a modulus b and returns the result in a new number (aliases: mod()) Tpa.frac(a) takes the fractional part of a and returns it in a new number Tpa.int(a) takes the integer part of a and returns it in a new number Tpa.abs(a) takes the absolute value of a and returns it in a new number var a=Tpa(5); var b=Tpa(12.5,false); console.log(Tpa.add(a,b).value()); // 17 console.log(Tpa.subtract(a,b).value()); // -7 console.log(Tpa.multiply(a,b).value()); // 60 console.log(Tpa.divide(b,a).toFraction());// '2 25/50' console.log(Tpa.modulus(a,b).value()); // 5 console.log(Tpa.frac(b).value()); // 0.5 console.log(Tpa.int(b).value()); // 12 console.log(Tpa.abs(-23).value()); // 23Note that for methods that take two arguments the first one dictates whether the result is integer or fractional. Thus the subtraction of 12.5 from 5 yields 7 as the operation is only working on integer parts. As opposed to the division that takes the type of b which is fractional. Method indexConstruction and mutators take numbers as parameters in the following forms: Tpa object Javascript number Javascript string (decimal or fractional format) Construction &amp; setting new Tpa() or Tpa() set() Mutators Unary frac() int() abs() makeInteger() makeFractional() Binary add() or plus() subtract() or sub() or minus() multiply() or mult() or times() divide() or div() modulus() or mod() Enquirers Unary sign() hasFraction() isZero() isPositive() isNegative() isInteger() isFractional() Binary lt() lte() gt() gte() eq() Output toDecimal() or toString() toFraction() value() Miscellaneous simplify() Note that all mutators are available as static methods to preserve the original value as per this example var x=Tpa(100); var y=Tpa(50); Tpa.divide(x,y); // Returns a new number = x/y, x and y remain unchanged x.divide(y); // Returns x having been divided by y, only y remains unchanged × Search results Close "},"module-N-N.html":{"id":"module-N-N.html","title":"Class: N","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Class: N N~ N new N(initialValue) N is the core vehicle to store and manipulate arbitrarily long integers This class is not intended for external use and is only used internally by the TPA class. It does not form any part of the TPA API. It is documented here for developer convenience and interest. The minified browser build gives no access to this class except except via the internals of Tpa objects For efficiency reasons many methods do not have error checking or may make assumptions about the state of the number.Any assumptions, however, are documented. Parameters: Name Type Argument Description initialValue Number | String | module:N~N &lt;optional&gt; The initial value assigned to this number.This may be a JS numeric value, a string or another N instance. If numeric, any fractional part is ignored.If string it may only contain digits starting with an optional + or - sign. If N, the new N will be a duplicate. Source: N.js, line 44 Throws: If parameter passed is not one of the above or is badly formed. Type external:Error Methods &lt;static&gt; abs(number) Create a positive version of the number given Parameters: Name Type Description number module:N~N The number to copy and make positive Source: N.js, line 268 Returns: A new number that is the positive version of number Type module:N~N &lt;static&gt; getBASE() The BASE to which all numbers are stored. This is preset to 2^25 which is the optimal size.However, it may be lower (not higher!) in order to test the integrity of internal representation and manipulation of numbers.In the browser version this method is not available. Source: N.js, line 105 Returns: Type Number &lt;static&gt; setBASE(base) Sets the BASE to which numbers are internally represented. This should only be set for experimentation and testing purposes.Any existing instances of Tpa will become corrupt or invalid once the base is changed.In the browser version this method is not available.Safe rule: Don't call this set method! Parameters: Name Type Description base Number The new BASE for number internal representation Source: N.js, line 90 abs() Make this number positive Source: N.js, line 277 Returns: This number for chaining purposes Type module:N~N add(number) Addition Parameters: Name Type Description number module:N~N The number to add to this number Source: N.js, line 288 Returns: This number for chaining purposes Type module:N~N compare(comparison) Compares two numbers Note This function can only be called when both numbers are positivised (and hence normalised) Parameters: Name Type Description comparison module:N~N The number to compare with this number Source: N.js, line 252 See: #positivise Returns: 0 if equal, -1 if this &lt; comparison, +1 if this &gt; comparison Type number digitDivide(digit) Division by a single digit The number provided must be less than BASE Parameters: Name Type Description digit Number The number to multiply with Source: N.js, line 492 Returns: The remainder Type Number digitMultiply(digit) Multiplication by a single digit The number provided must be less than BASE Parameters: Name Type Description digit Number The number to multiply with Source: N.js, line 372 Returns: This number for chaining purposes Type module:N~N divide(number) Division Parameters: Name Type Description number module:N~N The number to divide into this number Source: N.js, line 412 Throws: If divisor is zero Type Error Returns: The remainder. Note: This number is not returned, unlike most other mutation operations Type module:N~N isDivisibleBy(testDivisor) Checks for divisibility. The divisor must be positive and less than the BASE Parameters: Name Type Description testDivisor Number The number to test as a factor of this number Source: N.js, line 206 Returns: true if this number is divisible by the test-divisor Type Boolean isNegative() Source: N.js, line 160 Returns: true if this number is negative, false if zero or positive Type Boolean isPositive() Source: N.js, line 175 Returns: true if this number is positive, false if zero or negative Type Boolean isZero() Source: N.js, line 168 Returns: true if this number is zero Type Boolean lsb() Source: N.js, line 183 Returns: The least significant digit of the number or 0 if zero Type Number multiply(number) Multiplication Parameters: Name Type Description number module:N~N The number to multiply this number Source: N.js, line 338 Returns: This number for chaining purposes Type module:N~N negate() Make this number the opposite sign If the number is positive it will be made negative, if negative it will be made positive Source: N.js, line 308 Returns: This number for chaining purposes Type module:N~N normalise(noReduction) Ensures that all digits of this number are less than the BASE Internal representation allows for digits to exceed BASE. Normalisationis necessary where an impending operation depends on this not being the case.Note also that normalisation does not remove negative digits that arealso permitted. Again, for some operations, negative digits are undesiredand the positivise method is required to remove them. Parameters: Name Type Argument Default Description noReduction Boolean &lt;optional&gt; false set to true if we wish to keep any trailing zero digits Source: N.js, line 123 See: #positivise Returns: This number for chaining purposes Type module:N~N positivise() Removes any negative digits by carry over. This function should only be called once it is established that the number is both positive overalland is normalised. Source: N.js, line 146 See: #abs #normalise quotient(number) The quotient of this number after dividing it by the number given Parameters: Name Type Description number module:N~N The divisor Source: N.js, line 400 Returns: This number for chaining purposes Type module:N~N random(digits) Sets a number to a random value that is roughly the number of decimal digits given Parameters: Name Type Description digits Number The number of decimal digits required Source: N.js, line 382 Returns: This number for chaining purposes Type module:N~N reset() Resets number to zero Source: N.js, line 192 Returns: This number for chaining purposes Type module:N~N set(newValue) Sets a new numeric value into this number Parameters: Name Type Description newValue Number As per instantiation, setting Tpa with a JS native number is subject to accuracy constraints Source: N.js, line 219 Returns: This number for chaining purposes Type module:N~N subtract(number) Subtraction Parameters: Name Type Description number module:N~N The number to subtract from this number Source: N.js, line 319 Returns: This number for chaining purposes Type module:N~N toString() Decimal value of this number Source: N.js, line 509 Returns: The full decimal representation of this number Type String value() Gets the numeric value of this number The JS native number returned is subject to accuracy constraints and thus this method is only usefulas an indicator. Indeed, for very large numbers infinity can be returned. Source: N.js, line 238 Returns: The value of this number accurate to within the bounds of JS native floating point number Type Number × Search results Close "},"module-TPA-Tpa.html":{"id":"module-TPA-Tpa.html","title":"Class: Tpa","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Class: Tpa TPA~ Tpa new Tpa(initialValue, isInteger) Tpa stores and manipulates rational numbers with total precision Parameters: Name Type Argument Default Description initialValue number | string | module:TPA~Tpa &lt;optional&gt; Initial value to set this number. Numeric values are only represented to a precision of 8 decimal places and, in any case, are limited by the precision of a JS floating point number. To initialise a number with definite accuracy the string form is recommended. String values can be represented in decimal or fractional form. Decimal form: &lt;+/-&gt;iii.ddd[rrr] where +/- is optional, iii represents the integer part and ddd the decimal part with [rrr] representing an optional recurring decimal part Fractional form: &lt;+/-&gt; iii nnn/ddd where +/- is optional, iii represents the (optional) integer part, nnn the numerator and ddd the denominator. The fraction may be top heavy. Tpa instance causes this constructor to return a copy of it. Tpa may be called statically, in which case a new instance is still returned.Note well: If initialValue is itself a Tpa, then the same Tpa is returned without making a copy when called statically. isInteger boolean &lt;optional&gt; true Set to false to enable this number to represent fractions.If the initialValue is fractional in any way then isInteger will default to false.The initial setting of this number (integer or fractional) is always kept throughout its life unless the makeFractional or makeInteger methods are called to change it. Source: tpa.js, line 71 See: #makeFractional #makeInteger Throws: If the constructor parameters are not valid Type external:Error Example var a=new Tpa(); // Creates a new number set to zero var b=Tpa(20); // Creates a new number preset to 20 var c=Tpa['0.[6]']; // Creates a new number preset to 2/3 var d=new Tpa('2/3']; // Creates a new number preset to 2/3 var e=new Tpa('-4 538/1284'); // Creates a new number preset to -4.4[19003115264797507788161993769470404984423676012461059] var f=new Tpa(b); // Creates a new number preset to 20 var g=Tpa(e); // Does NOT create a new number: Object g references Object f var h=Tpa(false); // Creates a new number set to zero but is configured to represent fractions var i=Tpa(100,false); // Creates a new number set to 100 but is configured to represent fractions var j=Tpa(100.5,true); // Creates a new number set to 100 as we explicitly set it to be integer only and the fractional part is ignored var k=Tpa('10 20/3',true); // Creates a new number set to 16 as we explicitly set it to be integer only and the fractional part is ignored Methods &lt;static&gt; abs(n) Absolute value of a number Parameters: Name Type Description n number | string | module:TPA~Tpa The number Source: tpa.js, line 497 Returns: |n| Type module:TPA~Tpa &lt;static&gt; add(a, b) Adds two numbers Aliases: plus Parameters: Name Type Description a number | string | module:TPA~Tpa First number b number | string | module:TPA~Tpa Second number Source: tpa.js, line 435 Returns: a + b Type module:TPA~Tpa &lt;static&gt; divide(a, b) Divides two numbers ( a / b ) Aliases: div Parameters: Name Type Description a number | string | module:TPA~Tpa First number b number | string | module:TPA~Tpa Second number Source: tpa.js, line 474 Returns: a / b Type module:TPA~Tpa &lt;static&gt; frac(number) Sets the integer part of a number to zero Parameters: Name Type Description number number | string | module:TPA~Tpa The number from which the integer part is to be removed Source: tpa.js, line 413 &lt;static&gt; int(number) Sets the fractional part of a number to zero Parameters: Name Type Description number number | string | module:TPA~Tpa The number from which the fractional part is to be removed Source: tpa.js, line 422 &lt;static&gt; makeFractional(number) Sets a number to hold fractional value Parameters: Name Type Description number number | string | module:TPA~Tpa The number to copy Source: tpa.js, line 394 Returns: A new number with the ability to hold fractions Type module:TPA~Tpa &lt;static&gt; makeInteger(number) Sets a number to hold integer values only Parameters: Name Type Description number number | string | module:TPA~Tpa The number to copy Source: tpa.js, line 404 Returns: A new number without the ability to hold fractions Type module:TPA~Tpa &lt;static&gt; modulus(a, b) Modulus of two numbers Aliases: mod Parameters: Name Type Description a number | string | module:TPA~Tpa First number b number | string | module:TPA~Tpa Second number Source: tpa.js, line 487 Returns: a mod b Type module:TPA~Tpa &lt;static&gt; multiply(a, b) Multiplies two numbers Aliases: mult, times Parameters: Name Type Description a number | string | module:TPA~Tpa First number b number | string | module:TPA~Tpa Second number Source: tpa.js, line 461 Returns: a * b Type module:TPA~Tpa &lt;static&gt; random(digits) Creates a random number of an approximate number of decimal digits long Parameters: Name Type Description digits number The number of decimal digits Source: tpa.js, line 507 Returns: A new number set a a random value Type module:TPA~Tpa &lt;static&gt; subtract(a, b) Subtracts two numbers Aliases: minus, sub Parameters: Name Type Description a number | string | module:TPA~Tpa First number b number | string | module:TPA~Tpa Second number Source: tpa.js, line 448 Returns: a - b Type module:TPA~Tpa abs() Takes the absolute value of this number Source: tpa.js, line 606 Returns: This number for chaining purposes Type number | string | module:TPA~Tpa add(number) Adds the given number to this number Aliases: plus If this number is fractional, then it will perform a full fractional addition.If it is set as an integer then the addition will ignore any fractional part of the number to be added Parameters: Name Type Description number number | string | module:TPA~Tpa The number to add Source: tpa.js, line 713 Returns: This number for chaining purposes Type module:TPA~Tpa compare(number) Compares the given number with this number Parameters: Name Type Description number number | string | module:TPA~Tpa The number to compare Source: tpa.js, line 521 Returns: -1 if this number is less than the given number, 0 if equal, 1 if greater Type number divide(number) Divide this number by the one given Aliases: div If this number is fractional, then it will perform a full fractional division.If it is set as an integer then the division will ignore any fractional part of the divisor Parameters: Name Type Description number number | string | module:TPA~Tpa The number to multiply by Source: tpa.js, line 647 Returns: This number for chaining purposes Type module:TPA~Tpa eq(number) Parameters: Name Type Description number number | string | module:TPA~Tpa The number to compare Source: tpa.js, line 577 Returns: true if this number is equal to the given number Type boolean frac() Sets the integer part of this number to zero Source: tpa.js, line 596 Returns: This number for chaining purposes Type number | string | module:TPA~Tpa gt(number) Parameters: Name Type Description number number | string | module:TPA~Tpa The number to compare Source: tpa.js, line 561 Returns: true if this number is greater than the given number Type boolean gte(number) Parameters: Name Type Description number number | string | module:TPA~Tpa The number to compare Source: tpa.js, line 569 Returns: true if this number is greater than or equal to the given number Type boolean hasFraction() Source: tpa.js, line 363 Returns: true if this number has a non-zero fractional part Type boolean int() Sets the fractional part of this number to zero Source: tpa.js, line 586 Returns: This number for chaining purposes Type number | string | module:TPA~Tpa isFractional() Source: tpa.js, line 322 Returns: true if this number is capable of representing fractions Type boolean isInteger() Source: tpa.js, line 315 Returns: true if this number only represents integers Type boolean isNegative() Source: tpa.js, line 329 Returns: true if this number is less than zero Type boolean isPositive() Source: tpa.js, line 338 Returns: true if this number is greater than zero Type boolean isZero() Source: tpa.js, line 347 Returns: true if this number is equal to zero Type boolean lt(number) Parameters: Name Type Description number number | string | module:TPA~Tpa The number to compare Source: tpa.js, line 545 Returns: true if this number is less than the given number Type boolean lte(number) Parameters: Name Type Description number number | string | module:TPA~Tpa The number to compare Source: tpa.js, line 553 Returns: true if this number is less than or equal to the given number Type boolean makeFractional() Sets this number to accept fractional amounts, if not already set Source: tpa.js, line 304 Returns: This number for chaining purposes Type module:TPA~Tpa makeInteger() Sets this number to hold integers only - removes any existing fractional part Source: tpa.js, line 293 Returns: This number for chaining purposes Type module:TPA~Tpa modulus(number) Sets this number to the modulus of the number given Aliases: mod Fractional parts of either number are ignored - the modulus is based on the integer parts ony Parameters: Name Type Description number number | string | module:TPA~Tpa The divisor number Source: tpa.js, line 671 Returns: This number for chaining purposes Type module:TPA~Tpa multiply(number) Multiply this number by the one given Aliases: mult If this number is fractional, then it will perform a full fractional multiplication.If it is set as an integer then the multiplication will ignore any fractional part of the multiplier Parameters: Name Type Description number number | string | module:TPA~Tpa The number to multiply by Source: tpa.js, line 623 Returns: This number for chaining purposes Type module:TPA~Tpa set(initialValue, isInteger) Sets this number to a new value Parameters passed are exactly those expected for construction of a new Tpa Parameters: Name Type Argument Default Description initialValue number | string | module:TPA~Tpa &lt;optional&gt; Initial value to set this number. isInteger boolean &lt;optional&gt; true Set to false to enable this number to represent fractions. Source: tpa.js, line 111 Returns: this number for chaining purposes Type module:TPA~Tpa sign() Source: tpa.js, line 355 Returns: -1 if this number is negative, 0 if zero or 1 if positive Type number simplify(milliseconds) Attempts a simplification of the remaining fraction Finding common factors (which would be prime numbers) is a time-consuming job.Just as well, as otherwise most security mechanism (i.e. RSA) could be hacked in a jiffy.So there is a limit to how large a fraction can be simplified. A realistic limit has therefore beenestablished here whereby prime factors can not exceed the BASE of the internal number representation.Thus the highest prime explored is 33,554,393.Fractions that have their numerator larger than the square of this number may not be completely simplified - i.e. numbers of more than 15 digits. Parameters: Name Type Argument Default Description milliseconds number &lt;optional&gt; 100 The maximum time in milliseconds to attempt simplification. 0 sets no limit. Source: tpa.js, line 248 Throws: If an invalid limit is given Type external:Error Returns: true if simplification complete, false if there may still be some common factors left Type boolean subtract(number) Subtracts the given number from this number Aliases: sub, minus If this number is fractional, then it will perform a full fractional subtraction.If it is set as an integer then the subtraction will ignore any fractional part of the number to be subtracted Parameters: Name Type Description number number | string | module:TPA~Tpa The number to subtract Source: tpa.js, line 689 Returns: This number for chaining purposes Type module:TPA~Tpa toDecimal(maxDecimalPlaces) Outputs a decimal representation of this number All Tpa numbers are rational and thus have a limited or recurring set of decimal placesRecurring decimals are notated in square brackets - e.g. 33.[3] for 33 and one thirdIf there are more decimals to output than the maximum requested the output is cut off and finishes with an ellipsis (...) Parameters: Name Type Argument Default Description maxDecimalPlaces number &lt;optional&gt; 100 The maximum number of decimal places to give Source: tpa.js, line 737 See: #toString Returns: The number in format: [-]nnn.ddd[rrr] Type string toFraction() Outputs this number in fractional representation: [-]nnn nnn/nnn Source: tpa.js, line 756 Returns: The number in fractional form Type string toInteger() Outputs the decimal representation of the integer part of this number only Source: tpa.js, line 746 Returns: The number in decimal form: [-]nnn Type string toString(maxDecimalPlaces) Outputs a decimal representation of this number All Tpa numbers are rational and thus have a limited or recurring set of decimal placesRecurring decimals are notated in square brackets - e.g. 33.[3] for 33 and one thirdIf there are more decimals to output than the maximum requested the result is cut off andends with an ellipsis (...) Parameters: Name Type Argument Default Description maxDecimalPlaces number &lt;optional&gt; 100 The maximum number of decimal places to give Source: tpa.js, line 776 See: #toDecimal Returns: The number in format: [-]nnn.ddd[rrr] Type string value() Gets the value of this number in standard JS floating point number Note that precision may well be lost in order to accommodate the limitations of floating point numbers.For this reason, the number of decimal places is restricted to 8.Tpa numbers can be so large as to cause an overflow on a floating point number to yield infinity Source: tpa.js, line 378 Returns: A numeric value of this number Type number × Search results Close "},"external-Error.html":{"id":"external-Error.html","title":"External: Error","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error External: Error N~ Error The built in error object. Source: N.js, line 12 See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error × Search results Close "},"module-N.html":{"id":"module-N.html","title":"Module: N","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Module: N An internal module to store large integers for Total Precision Arithmetic Author: Dominic Thwaites Copyright: (c) 2016 Dominic Thwaites dominicthwaites@mac.com Source: N.js, line 1 Classes N Members &lt;inner, constant&gt; INPUT_ERROR_MESSAGE The error message given when passing an invlaid initial value for a new number Source: N.js, line 28 × Search results Close "},"module-TPA.html":{"id":"module-TPA.html","title":"Module: TPA","body":" TPA Modules NTPA Classes N~NTPA~Tpa Externals Error Module: TPA The complete code for Total Precision Arithmetic Author: Dominic Thwaites Copyright: (c) 2016 Dominic Thwaites dominicthwaites@mac.com Source: tpa.js, line 1 Classes Tpa Members &lt;inner, constant&gt; INPUT_ERROR_MESSAGE The error message given when passing an invalid initial value for a new number Source: tpa.js, line 17 &lt;inner, constant&gt; VALUE_DECIMAL_PLACES number of DPs to take from a numeric construction and to output with the value() method Source: tpa.js, line 23 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
